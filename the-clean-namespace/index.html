<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="../base.css">

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100..800&display=swap" rel="stylesheet">
  </head>
  <body>
    <a id="top"></a>
    <h5><a href="../">emanueljg.com</a></h5>
    <h1>The clean namespace</h1>
    <hr>
    <div style="margin-left: 30px;"><i>2025-08-22 | Nix</i></div>
    <hr>
    <br>

    It's common for software to have a lot of footguns, especially if it's flexible and powerful software. 
    Nix, however, overwhelms you with entire <i>keywords</i> that are dangerous to use: <code>rec</code> and <code>with</code>. 
    This is an explanation on what they do, why you should avoid them and a better way to do what they do (<i>without</i> sacrificing DRY or elegance!).

    <br><br>
    <h2 id="rec"><a class="hover-underline" href="#rec">rec</a></h2>
    <code>rec</code> creates a recursive attribute set. 
    <pre class="codeblock">
      
attrs = let a = "fi"; b = "bur"; in rec {
  a = "foo";
  b = "bar";
  y = a + b;
}
    </pre>
    <br>
    
    It's commonly used across all of Nix. It lets attributes in an attribute set refer to each other.<br><br>
    
    First of, why is it bad? Well, I think it's personally quite annoying to read implicit recursion (explicit alternatives are covered later). 
    It's also easy to accidentally create infinite recursion with <code>rec</code>, where an attribute depends on itself.
    It means that given any referenced value in a recursive attribute set, you always have to look through the <i>entire</i> attrset to check whether the value comes from the attrset or an outer binding. This is very annoying.
    But worse, <code>rec</code> creates <i>namespace pollution</i>. What does that mean?<br><br>

    Consider <code>attrs</code> in the first example. As you might've guessed, <code>attrs.y</code> evaluates to <code>foobar</code>, since the <code>rec</code> <i>shadows</i> the outer <code>let</code>-bindings <code>a= "fi"</code> and <code>a = "bur"</code>. 
    This leads to decisively unreadable structures and brittle evaluation. 
    Imagine what happens in a refactor when you change the name of <code>attrs.a = "foo"</code> to <code>attrs.aaa = "foo"</code>. Your <code>y</code> mysteriously takes on the value <code>fibar</code> because <code>a</code> remains a valid binding outside of the attrset. 
    Easy mistake to make, hard mistake to troubleshoot.<br><br>

    This example attrset is a softball. 3 lines of primitive attributes with one line of outer bindings; 
    it's trivial for pedagogical purposes. Now imagine instead of <code>a</code> and <code>b</code> you're using "attractive" 
    attr names like <code>name</code> or <code>default</code>, which may hold important semantic importance in the outer bindings. 
    Maybe you're 20, 30 attrs deep and you've scrolled past where the attrset's opening <code>{</code>. 
    Maybe you're focused on things more important than namespace resolution. 
    It's easy to see the code in the future blowing up because wires get crossed and mysterious values show up where they shouldn't.<br><br>

    There is a solution. In fact, there's multiple!<br><br>

    Starting of simple, you should generally prefer already paved roads for getting attrs when you can. Here follows a few example substitutions using already available bindings.<br><br>

    <h3><code>flake.nix</code></h3>

    Your flake already gives you <code>self</code> in the <code>outputs = { self, nixpkgs, ... }@inputs:</code> function. Use it!

    <pre class="codeblock">

packages.${system} = {
  foopkg = pkgs.callPackage ./foopkg.nix { };
  default = self.packages.${system}.foopkg;
};
    </pre>



    
    <br><br>
      <a href="../."> <<< back to emanueljg.com</a>&nbsp;&nbsp;&nbsp;<a href="#top"> ^ Top</a>
      <br></br>

      <hr>
      <small>discord: @psibusinessman</small>
      <br>
      <small>email: emanueljohnsongodin@gmail.com</small>
      <br>
  </body>
</html>
