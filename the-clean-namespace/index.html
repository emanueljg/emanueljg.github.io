<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="../base.css">

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100..800&display=swap" rel="stylesheet">
  </head>
  <body>
    <a id="top"></a>
    <h5><a href="../">emanueljg.com</a></h5>
    <h1>The clean namespace</h1>
    <hr>
    <div style="margin-left: 30px;"><i>2025-08-22 | Nix</i></div>
    <hr>
    <br>

    It's common for software to have a lot of footguns, especially if it's flexible and powerful software. 
    Nix, however, overwhelms you with entire <i>keywords</i> that are dangerous to use: <code>rec</code> and <code>with</code>. 
    This is an explanation on what they do, why you should avoid them and a better way to do what they do (<i>without</i> sacrificing DRY or elegance!).

    <br><br>
    <h2 id="rec"><a class="hover-underline" href="#rec">rec</a></h2>
    <code>rec</code> creates a recursive attribute set. 
    <pre class="codeblock">
      
attrs = let a = "fi"; b = "bur"; in rec {
  a = "foo";
  b = "bar";
  y = a + b;
}
    </pre>
    <br>
    
    It's commonly used across all of Nix. It lets attributes in an attribute set refer to each other.<br><br>
    
    First of, why is it bad? Well, I think it's personally quite annoying to read implicit recursion (explicit alternatives are covered later). 
    It's also easy to accidentally create infinite recursion with <code>rec</code>, where an attribute depends on itself.
    It means that given any referenced value in a recursive attribute set, you always have to look through the <i>entire</i> attrset to check whether the value comes from the attrset or an outer binding. This is very annoying.
    But worse, <code>rec</code> creates <i>namespace pollution</i>. What does that mean?<br><br>

    Consider <code>attrs</code> in the first example. As you might've guessed, <code>attrs.y</code> evaluates to <code>foobar</code>, since the <code>rec</code> <i>shadows</i> the outer <code>let</code>-bindings <code>a= "fi"</code> and <code>a = "bur"</code>. 
    This leads to decisively unreadable structures and brittle evaluation. 
    Imagine what happens in a refactor when you change the name of <code>attrs.a = "foo"</code> to <code>attrs.aaa = "foo"</code>. Your <code>y</code> mysteriously takes on the value <code>fibar</code> because <code>a</code> remains a valid binding outside of the attrset. 
    Easy mistake to make, hard mistake to troubleshoot.<br><br>

    This example attrset is a softball. 3 lines of primitive attributes with one line of outer bindings; 
    it's trivial for pedagogical purposes. Now imagine instead of <code>a</code> and <code>b</code> you're using "attractive" 
    attr names like <code>name</code> or <code>default</code>, which may hold important semantic importance in the outer bindings. 
    Maybe you're 20, 30 attrs deep and you've scrolled past where the attrset's opening <code>{</code>. 
    Maybe you're focused on things more important than namespace resolution. 
    It's easy to see the code in the future blowing up because wires get crossed and mysterious values show up where they shouldn't.<br><br>

    There is a solution. In fact, there's multiple!<br><br>

    Starting of simple, you should generally prefer already paved roads for getting attrs when you can. Here follows a few example substitutions using already available bindings.<br><br>

    <br><h3><code>flake.nix</code></h3>

    Your flake already gives you <code>self</code> in the <code>outputs = { self, nixpkgs, ... }@inputs:</code> function. Use it!

    <pre class="codeblock">

packages.${system} = {
  foopkg = pkgs.callPackage ./foopkg.nix { };
  default = self.packages.${system}.foopkg;
};
    </pre>

    <br><h3><code>stdenv.mkDerivation</code></h3>

    For a few derivation types, you can provide a <code>self</code>-function (more on this later).

    <pre class="codeblock">
      
stdenv.mkDerivation (self: {
  pname = "foo";
  version = "0.1.0"; 

  src = fetchFromGithHub {
    owner = ...
    repo = ...
    tag = "v${self.version}";
  };
})
    </pre>

    <br>If these "prefab" solutions aren't applicable to your current problem, you have two generic ones. Both of them are equally good, though one is certainly more common than the other.

    <br><br><h3><code>let..in</code> + <code>inherit</code></h3>

    <pre class="codeblock">
      
let
  a = "foo";
  b = "bar";
in {
  inherit a b;
  y = a + b;
}
    </pre>

    Intuitive, idiomatic and categorically better than <code>rec</code>. This is probably the most common solution to the problem and always a valid strategy. 

    <br><br><h3><code>lib.fix</code></h3>
    
    The alternative solution is a bit more complicated: it utilizes <code>lib.fix</code> to create something called a fixed-point attribute set (similar to our <code>stdenv.mkDerivation</code> example)

    <pre class="codeblock">
      
attrs = lib.fix (self: {
  a = "foo";
  b = "bar";
  ab = self.a + self.b;
})
    </pre>
    <div style="padding-left: 10px; border-left: 5px solid #A7C080;"><i>
      For the intellectually curious: as you might've guessed, <code>stdenv.mkDerivation</code> 
      internally creates the fixed-point attrset which allows you to pivot to <code>self: { ... }</code> without using <code>lib.fix</code>. <code>rustPlatform.buildRustPackage</code> does this too. 
      To allow for your own <code>mkDerivation</code>-like function to use this feature, make sure to implement it using <code>lib.extendMkDerivation</code>` (<a href="https://noogle.dev/f/lib/extendMkDerivation">noogle docs</a>). 
      At the time of writing, there's not many derivation functions using this sadly. 
    </i></div>

    <br><h3><code>let..in</code> recursion</h3>

    Though I personally dislike this technique as I consider it "hacky" self-reference... I am still presenting it in this post, as its very common in the wild and it's better to know what it does. 
    
    <pre class="codeblock">

attrs = let
  a = "foo";
  b = "bar";
  ab = attrs.a + attrs.b;
}; in
  attrs;
    
    </pre>

    This might not be something you have thought of before, but <code>let..in</code>-blocks are actually inherently recursive in their scope, meaning <code>attrs</code> is a valid binding in <code>let attrs = ...</code>. While this pattern is very common, 
    I much prefer <code>lib.fix</code> as it's clearer to read the intent and flow of code. But it's still better than <code>rec</code> as the recursion is still explicit. 

    
    <br><br>
    <h2 id="with"><a class="hover-underline" href="#with">with</a></h2>

    This one might be surprising to some people, considering how extremely common it is. <code>with</code> takes all attrs of an attrset and brings them into scope.

    <pre class="codeblock">
      
environment.systemPackages = with pkgs; [
  # pkgs.foo, pkgs.bar, pkgs.baz
  foo
  bar
  baz
]
    </pre>
   
    You've probably seen this <code>with pkgs</code> construct a thousand times. Heck, even <code>nixos-generate</code> will give you a <code>with</code>-list of packages. 
    It's also commonly used as <oode>with lib;</oode> in modules and the <code>mkDerivation.meta</code> attrset.<br><br>

    Despite how common it is, me and many other intermediate NixOS users consider it bad code. 
    As with <code>rec</code>, it's bad due to namespace pollution, but in this case you're polluting it with (at the time of writing) <b><i>~25 000 attributes</i></b>.
    It's especially bad considering OS packages are frequently flip-flopping between being taken from nixpkgs and being local "custom" derivations, 
    meaning it's easy to have attribute shadowing.<br><br>

    What's the alternative? If you just have 1-4 attributes, I think you can just repeat <code>pkgs.</code> for them, it's not a lot of work (and with <code>with lib;</code>, this is actually the idiomatic approach) 
    but if you want to maintain DRY in especially package lists, there is actually a really neat trick!

    <pre class="codeblock">

environment.systemPackages = builtins.attrValues {
  inherit (pkgs)
    foo
    bar
    baz
  ;
}
    </pre>

    I'll be entirely honest and admit that I didn't understand the point of this pattern until recently and muttered to myself when I saw it: 
    "you're still bringing the entirety of <code>pkgs</code> into scope with <code>inherit</code>, thereby polluting the namespace, so what's the point?" 
    Yes, while that's true, I failed to consider that <code>inherit</code> obviously by nature doesn't allow for any non-<code>pkgs</code> attributes in the first place, thereby sidestepping the problem of flip-flopping attribute shadowing entirely. Clever! 

    <pre class="codeblock">

environment.systemPackages = let
  foreign-bar = ...; 
  foreign-baz = ...; 
in builtins.attrValues {
  inherit (pkgs)
    foo
    # illegal!
    foreign-bar
  ;
  # ok!
  foreign-baz
}
    </pre>

    Last but not least, I'll round this post off with a small exception to the outlawing of <code>with</code>: 
    while I think that <code>rec</code> is categorically bad in any and all code, <code>with</code> actually has a very niche use case; 
    composite NixOS option type declarations.

    <pre class="codeblock">
      
colors = lib.mkOption {
  type = with lib.types; listOf str;
  ...
}

    </pre>

    Why is <code>with</code> OK specifically here? Because it makes the type declaration read like English and makes it much easier to skim through options. 
    Just be careful to not use it if you're inlining a <code>lib.types.submoudle</code>! If you use <code>with lib.types;</code> there, you're propagating the <code>with</code> 
    to the entire submodule which brings us back to the same problem. In that case, either write all <code>lib.types</code> members explicitly or consume the submodule type from a <code>let</code>-binding.

    <br><br>
      <a href="../."> <<< back to emanueljg.com</a>&nbsp;&nbsp;&nbsp;<a href="#top"> ^ Top</a>
      <br></br>

      <hr>
      <small>discord: @psibusinessman</small>
      <br>
      <small>email: emanueljohnsongodin@gmail.com</small>
      <br>
  </body>
</html>
