<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="../base.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100..800&display=swap" rel="stylesheet">

  </head>
  <body>
    <a id="top"></a>
    <h5><a href="../">emanueljg.com</a></h5>
    <h1>Stop lying about <code>pkgs</code>!</h1>
    <hr>
    <div style="margin-left: 30px;"><i>2025-08-08 | Nix</i></div>
    <hr>
    <h2 id="1-what-are-overlays-why-are-they-bad"><a class="hover-underline" href="#1-what-are-overlays-why-are-they-bad">1. What are overlays? Why are they bad?</a></h2>
    <p>
      Consider the following Nix code:

      <pre class="codeblock">

{ pkgs, ... }: {

  environment.systemPackages = [
    pkgs.foo
  ];

}
      </pre>

      NixOS users will be very familiar with this configuration pattern: it's a NixOS module that adds a package to your system. We can
      confidently reason about this piece of configuration:

      <ul>
        <li>The package comes from the Nix package repository <code>nixpkgs</code>,</li>
        <li>and it's the package <code>foo</code>.</li>
      </ul>

      But those are only assumptions we make, and there's nothing stopping us from lying about <code>pkgs.foo</code>. Are you absolutely sure
      you're installing <code>foo</code> and not <code>bar</code>, for instance?

      <pre class="codeblock">

{ pkgs, ... }: {

  nixpkgs.overlays = [
    (final: prev: { foo = final.bar; })
  ];

  environment.systemPackages = [
    pkgs.foo  # pkgs.bar in a disguise
  ];

}
      </pre>

      The code above uses an <i>overlay</i>, which is a tool to change and extend nixpkgs. It works like this:
      In short, each overlay is a Nix function accepting the two arguments <code>final</code> and <code>prev</code>, with <code>final</code>
      representing the "finalized" nixpkgs state and <code>prev</code> representing the previous stage of overlaying.

      <br><br><br>
      <img src="./overlay.png" style="background-color:beige;">
      <br>
      <small><i>How overlaying works (credit: wiki.nixos.org)</i></small>
      <br><br><br>

      In the example given, we took the final <code>bar</code> and assigned it to <code>foo</code>. This change gets applied to the <code>{ pkgs, ... }</code>
      module argument, which obviously in turn changes what <code>pkgs.foo</code> evaluates to in our <code>environment.systemPackages</code> list.

      <br><br>
      In other words, we have now successfully lied about <code>pkgs</code>.
      <br><br>

      Why do people lie? Because they're taught it as a solution.
      In fact, there's a multitude of problems that arise from using Nix that overlays solve:

      <ul>
        <li>"I want to use the absolutely newest version of a package but nixpkgs doesn't have it"</li>
        <li>"I need to patch this package in order for it to work"</li>
        <li>"I want to distribute custom packages or derivation builders that I've made"</li>
      </ul> 

      Overlays solves these problems and with quite little code too. Just import a single overlay into your configuration and you
      get all of this magic at your fingertips. But the cost is that you have to lie. There is a beauty in knowing that <code>pkgs</code> is
      a pristine snapshot of <code>github:NixOS/nixpkgs</code> at a point in time. Overlays ruin that.
      
      <br><br>
      <b>Any given module adding an overlay propagates the lie across your entire configuration:</b> Our module above
      played nice; overlay defined and consumed in the same module. Let's play dirty.<br><br>

      <i>./bar.nix</i>
      <pre class="codeblock">

{

  nixpkgs.overlays = [
    (final: prev: { foo = final.bar; })
  ];

}
      </pre><br>
      <i>./foo.nix</i>
      <pre class="codeblock">

{ pkgs, ... }: {

  programs.foo = {
    enable = true;
    ...
  };
}
      </pre><br>
      <i>./configuration.nix</i>
      <pre class="codeblock">

{
  imports = [
    ./bar.nix
    ./foo.nix
    ...
  ];

}
      </pre>
      Now it's suddenly not so easy to troubleshoot <code>foo</code>'s mysterious <code>bar</code> tendencies if you're spending an entire evening debugging <code>./foo.nix</code>.

      
      <br><br>
      <b>Any given module adding an overlay propagates the lie across all</b> <code>callPackage</code> <b>calls:</b> Perhaps a more serious problem for intermediate NixOS users who
      have begun to package software is that their <code>callPackage</code> calls now have been infected with mystery meat derivation arguments. This might not be a problem
      for $CURRENT_DAY you which is familiar with the overlayed args, but it might be for $CURRENT_DAY+1 you, or someone other than you reading the code.

      <pre class="codeblock">

{ pkgs, ... }: {

  environment.systemPackages = [
    (pkgs.callPackage ({
      stdenv,
      fetchFromGitHub
      impostorPkg,         # who the hell are you?
      mysteriousSetupHook  # grep nixpkgs: 0 results 
    }: stdenv.mkDerivation {
      name = "foo";
      nativeBuildInputs = [
        impostorPkg  
        mysteriousSetupHook
      ];  
      installPhase = ''
        # ????? 
        impostor-pkg --flub-with-grubs $src $out
      '';
    }) { })
  ];

}
      </pre>
      <b>All of this implicit magic is extremely confusing to new Nix(OS) users!</b> Luckily, there is a solution: <code>specialArgs</code>.

      <h2 id="2-what-should-i-replace-my-overlays-with"><a class="hover-underline" href="#2-what-should-i-replace-my-overlays-with">2. What should I replace my overlays with?</a></h2>
      <b>I love </b><code>specialArgs</code><b>.</b> I am not seeing them nearly enough in people's configs. You should
      learn to love <code>specialArgs</code>, too. If you want to make your NixOS configuration more idiomatic, elegant and DRY instantly
      there's 3 things you should be littering all your config with: custom options, custom derivations, and <code>specialArgs</code>. Here
      follows how to use the latter of the 3.

      <br><br>
      <i>./flake.nix</i>
      <pre class="codeblock">

nixosConfigurations.bobs-pc = let
  system = "x86_64-linux";
in nixpkgs.lib.nixosSystem {
  inherit system;
  modules = [
    ./foo.nix
    ./hyprpaper.nix 
    # inlined for brevity
    ({ pkgs, weirdlib, ... }: {
      environment.systemPackages = [
        (pkgs.callPackage ./weird-hello.nix { inherit weirdlib; })
      ];
    })
    ...
  ];
  /*
    Note:
    A very common pattern is putting the entire 'inputs' attrset
    into 'specialArgs', i.e. specialArgs = { inherit inputs; };
    That's probably what you should do in real code instead of this,
    but it's done this way for demonstration purposes
    (and to show that `specialArgs.inputs` is *just* an attribute
    like any other!)
  */
  specialArgs = {
    specialFooPkg = inputs.foo-git.packages.${system}.foo;
    inherit (inputs) wallpapers;
    weirdlib = {
      inherit (inputs.weird)
        mkWeirdPackage
        mkWeirdApplication
      ;
    };
  };
};

    </pre><br>
    <i>./foo.nix</i>
    <pre class="codeblock">
    
{ specialFooPkg, ... }: {

  programs.foo = {
    enable = true;
    package = specialFooPkg;
  };

}
    </pre><br>
    <i>./hyprpaper.nix</i>
    <pre class="codeblock">

{ lib, wallpapers, ... }: {

  services.hyprpaper = {
    enable = true;
    settings = {
      splash = lib.mkDefault false;
      wallpaper = [
        "DP-2,${wallpapers.sunny-day}"
        "DP-1,${wallpapers.rainy-evening}"
      ];
    };
  };

}
    </pre><br>
    <i>./weird-hello.nix</i>
    <pre class="codeblock">

{ weirdlib
, fetchFromGitHub
, symlinkJoin
}: weirdlib.mkWeirdPackage {
  pname = "hello-weird";
  version = "0.1.0";

  src = fetchFromGitHub ...
  ...
}
      </pre>

      Notice we're still pulling in custom stuff from outside of our configuration and being just as ergonomic as an overlay,
      but now the custom stuff is easily traceable, and easily recognized as foreign attributes,
      as we can see it clearly written in the module function args - <b>no more lies, only honesty.</b>
      And If you're ever unsure of what a <code>specialArg</code> is or what it does, it's trivial to open up the <code>flake.nix</code> and follow
      the breadcrumb trail.


      <h2 id="2-does-that-mean-i-should-never-use-overlays"><a class="hover-underline" href="#3-does-that-mean-i-should-never-use-overlays">3. Does that mean I should never use overlays?</a></h2>
      No. There are 3 instances where they actually make sense:

      <ol>
        <li><u>Overriding driver packages & similar.</u> A large majority of NixOS modules are written such that they allow
        you to set a custom <code>.package</code> option. Certain modules aren't, for example <code>services.xserver.videoDrivers = [ ... ]</code>.
        Notice the lack of entrypoint to set your own package here, even if some individual drivers <i>do</i> have entrypoints
        elsewhere (e.g. <code>hardware.nvidia.package</code>).
        For modules like these, you have no other option than to use an overlay <i>(though sometimes the lack of entrypoint is due to
        an incompetent module author, in which case make your own PR fixing that!)</i></li>
        <li><u>Overriding very deep & wide dependencies</u>. There are certain <code>pkgs</code> members which are so immensely
        base that it would be ridiculous to try and override all of the time that they're consumed by other packages
        (think <code>stdenv' = stdenv.override { ... }</code>). In cases like these, overlays make sense <i>though you should
        think twice about making such base overrides!</i>
        <li><u>Temporary ad-hoc code.</u> As long as you are aware of the code being a dirty hack to get something working quickly,
        I think it's fine to temporarily add an overlay to tinker with <code>pkgs</code>. Just be prepared for the resulting tech debt.</li>
      </ol>

      In short, overlays have their niche use cases, but they are widely overused today.

      <br><br>
      <b>Together, let's stop lying and start telling the truth again.</b>

      <br></br>
      <a href="../."> <<< back to emanueljg.com</a>&nbsp;&nbsp;&nbsp;<a href="#top"> ^ Top</a>
      <br></br>

      <hr>
      <small>discord: @psibusinessman, email: emanueljohnsongodin@gmail.com</small>
      <br>
  </body>
</html>
