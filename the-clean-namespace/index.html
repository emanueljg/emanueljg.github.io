<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="../base.css">

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100..800&display=swap" rel="stylesheet">
  </head>
  <body>
    <a id="top"></a>
    <h5><a href="../">emanueljg.com</a></h5>
    <h1>The clean namespace</h1>
    <hr>
    <div style="margin-left: 30px;"><i>2025-08-22 | Nix</i></div>
    <hr>
    <br>

    It's common for software to have a lot of footguns, especially if it's flexible and powerful software. 
    Nix, however, overwhelms you with entire <i>keywords</i> that are dangerous to use: <code>rec</code> and <code>with</code>. 
    This is an explanation on what they do, why you should avoid them and a better way to do what they do (<i>without</i> sacrificing DRY or elegance!).
    
    <h2 id="rec"><a class="hover-underline" href="#rec">rec</a></h2>
    <code>rec</code> creates a recursive attribute set. 
    <pre class="codeblock">
      
attrs = let a = "fi"; b = "bur"; in rec {
  a = "foo";
  b = "bar";
  y = a + b;
}
    </pre>
    <br>
    
    It's commonly used across all of Nix. It lets attributes in an attribute set refer to each other.<br><br>
    
    First of, why is it bad? Well, I think it's personally quite annoying to read implicit recursion (explicit alternatives are covered later). 
    It's also easy to accidentally create infinite recursion with <code>rec</code>, where an attribute depends on itself.
    It means that given any referenced value in a recursive attribute set, you always have to look through the <i>entire</i> attrset to check whether the value comes from the attrset or an outer binding. This is very annoying.
    But worse, <code>rec</code> creates <i>namespace pollution</i>. What does that mean?<br><br>

    Consider <code>attrs</code> in the first example. As you might've guessed, <code>attrs.y</code> evaluates to <code>foobar</code>, since the <code>rec</code> <i>shadows</i> the outer <code>let</code>-bindings <code>a= "fi"</code> and <code>a = "bur"</code>. 
    This leads to decisively unreadable structures and brittle evaluation. 
    Imagine what happens in a refactor when you change the name of <code>attrs.a = "foo"</code> to <code>attrs.aaa = "foo"</code>. Your <code>y</code> mysteriously takes on the value <code>fibar</code> because <code>a</code> remains a valid binding outside of the attrset. 
    Easy mistake to make, hard mistake to troubleshoot. 

    
    <br><br>
      <a href="../."> <<< back to emanueljg.com</a>&nbsp;&nbsp;&nbsp;<a href="#top"> ^ Top</a>
      <br></br>

      <hr>
      <small>discord: @psibusinessman</small>
      <br>
      <small>email: emanueljohnsongodin@gmail.com</small>
      <br>
  </body>
</html>
